# 🥞Kruskal MST

## 알고리즘
: 탐욕적인 방법 [greedy method] </br> 

- 각 단계에서 최선의 답을 선택하는 과정을 반복함으로써 최종적인 해답에 도달
- 항상 최적의 해답을 주는 지 검증필요
     - _Kruskal_ 은 증명됨!

</br>

- 그래프의 간선들을 오름차순으로 정렬
-  정렬된 간선들의 리스트에서 **사이클을 형성하지 않는 간선**을 찾아 현재의 MST 집합에 추가한다.
- 만약 사이클을 형성하면 그 간선은 제외된다.

🌟사이클이 생기지 않게 하려면 어떻게 해야할까?
- 서로 다른 집합에 속하는 정점을 연결해야한다.
 </br>== 추가하고자 하는 간선의 양 끝 정점이 같은 집합에 속해있는지 검사한다.
    - 검사 : **`union-find`**

## `union-find` 
- union(x,y) : x, y가 속해있는 집합을 입력으로 받아 2개의 집합의 합집합을 만든다.
- find (x) : 원소 x가 속해있는 집합을 반환한다.
    - ex) {1}, {2}, {3}, {4}, {5}, {6} </br>
            -> union(1,4), union(5,2)
            => {1, 4}, {5, 2}, {3}, {6}
---
</br>

## 구현 
- 비트벡터, 배열, 연결리스트 ...
- 가장 효율적인 방법 :  **트리**
    - `부모 포인터 표현` :  각노드에 대해 그 노드의 부모에 대한 포인터만 저장 
        - 노드의 가장 왼쪽/오른쪽 자식을 찾는 작업에는 ❌
        - but, 두 노드가 같은 트리에 있는가?  ⭕

        - 배열로 구현 가능  
            - 부모노드의 인덱스 저장, 배열의 값이 -1 이면 부모 노드가 없는 것!

                |A|B|C|D|E|
                |:-:|:-:|:-:|:-:|:-:|
                -1|-1|-1|-1|-1

                *union(A, B)* 

                |A|B|C|D|E|                     
                |:-:|:-:|:-:|:-:|:-:|
                -1|0|-1|-1|-1
                
                : B의 0은 A의 idx

                *union(C, E)*

                |A|B|C|D|E|
                |:-:|:-:|:-:|:-:|:-:|
                -1|0|-1|-1|2

                : E의 2는 C의 idx

- `void set_init(n)` : 6을 넣으면 {0} ... {5}
- `int set_find(정점)` : 정점이 속하는 집합 반환
- `void set_union(대표정점1, 대표정점2)` : 두 개의 원소가 속한 집합을 합친다. 
----
</br>


## 👀그림으로 확인 
 ![kruskal](/Images/Kruskal.JPG)

 1. 간선 정렬 : qsort() 사용
    - [qsort](/C_Standard_Library/qsort.md)
