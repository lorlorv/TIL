# 완전탐색(Brute Force)

- 컴퓨터의 빠른 계산 능력을 이용하여 가능한 경우의 수를 일일이 나열하며 답을 찾는 방법
- Brute Force 라고도 부르는데, 뜻은 무식하게 푼다!
- 완전탐색은 알고리즘이 아닌, **문제를 푸는 방법**이라고 할 수 있다.
</br>
</br>
---
</br>

> 완전 탐색 기법 </br>

`1. 단순 Brute Force`
- if문이나 for문을 사용해 모든 case를 탐색하는 방법 

`2. Bit-mask`
- 모든 경우의 수가 각각의 원소에 포함되거나 포함되지 않는 **두 가지 선택**으로 구성되는 경우 용이하다.
- 이를 통해 집합을 정수로 나타내거나 집합의 모든 부분집합을 정수로 표현할 수 있다.

```
{1, 2, 3, 4, 5} -> 1 1 1 1 1 -> 31
{1, 2, 3, 4}    -> 1 1 1 1 0
{2, 3, 5}       -> 0 1 1 0 1
{3, 4}          -> 0 0 1 1 0
{1}             -> 1 0 0 0 0

: 모든 원소가 있는 부분집합 == 31
```
- 만약, 해당 부분집합에 i를 추가하고 싶다면 i번째 비트를 1로 바꿔주면 됨 
    - 이때 비트연산을 활용!
        - AND OR XOR NOT SHIFT

`3. 백 트래킹`
- 완전 탐색 도중 해가 되지 않을 것 같은 경로가 있다면 진행하지 않고 back한다.

`4. 재귀` </br>
`5. 순열`
- for문 사용
    - 수가 적을 때 사용한다.
- 재귀 
    ```C
    int n = 4, r = 3; //4개 중에서 3개 뽑기
    int check[4]; 
    int result[3]; //결과를 담을 배열
    int arr[] = { 1,2,3,4 };
    ```
    ```C
    void permutation(int idx) { //순열
        if (idx == r) {
            for (int i = 0; i < r; i++) {
                printf("%d", result[i]);
            }
            printf("\n");
            return;
        }

        for (int i = 0; i < n; i++) {
            if (check[i] != 1) {
                result[idx] = arr[i];
                check[i] = 1; // TRUE
                permutation(idx + 1);
                check[i] = 0; //FALSE
            }
        }
    }
    ```

`5. BFS/DFS`
